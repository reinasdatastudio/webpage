}
})
missing_summary
get_mode <- function(x) {
ux <- na.omit(unique(x))
ux[which.max(tabulate(match(x, ux)))]
}
View(get_mode)
df_final <- traffic_data %>%
mutate(across(where(is.character),
~ ifelse(is.na(.), get_mode(.), .)))
View(df_final)
get_mode <- function(x) {
x_no_blank <- x[x != ""]              # remove empty strings
if (length(x_no_blank) == 0) return("") # all blank â†’ leave as blank or set to NA
ux <- unique(x_no_blank)
ux[which.max(tabulate(match(x_no_blank, ux)))]
}
df_final <- traffic_data %>%
mutate(across(where(is.character),
~ ifelse(. == "", get_mode(.), .)))
View(df_final)
missing_summary <- sapply(df_final, function(x) {
if (is.character(x)) {
sum(is.na(x) | x == "")
} else if (is.numeric(x)) {
sum(is.na(x))
} else {
0  # other types like factors, dates, etc.
}
})
missing_summary
if (is.character(x)) {
sum(x == "")
} else if (is.numeric(x)) {
sum(is.na(x))
}
missing_summary <- sapply(df_final, function(x) {
if (is.character(x)) {
sum(x == "")
} else if (is.numeric(x)) {
sum(is.na(x))
}
})
missing_summary
library(pacman)  # No message.
# Or, by using "pacman::p_load" you can use the p_load
# function from pacman without actually loading pacman.
# These are packages I load every time.
pacman::p_load(pacman, dplyr, GGally, ggplot2, ggthemes,
ggvis, httr, lubridate, plotly, rio, rmarkdown, shiny,
stringr, tidyr)
data(diamonds)
summary(diamonds$price)
table(diamonds$cut)
library(tibble)
as_tibble(diamonds)
is_tibble(diamonds)
library(psych)
describe(diamonds$price)
install.packages("skimr")
install.packages("skimr")
library(skimr)
skim(diamonds)
#Filtering
diamonds %>% count(cut)
table(diamonds$cut)
View(diamonds)
#Diamonds more than 1 carat that is over $10000
top_diamonds <- diamonds %>% filter(price>=10000 && carat>=1)
#Diamonds more than 1 carat that is over $10000
top_diamonds <- diamonds %>% filter(price>=10000 & carat>=1)
View(top_diamonds)
mean_premium <- mean(diamonds$price[diamonds$cut == 'Premium'])
mean_ideal <- mean(diamonds$price[diamonds$cut == 'Ideal'])
ggplot(diamonds, aes(x = cut, y = price)) +
geom_boxplot(fill = "lightblue") +
labs(title = "Diamond Price Distribution by Cut",
x = "Cut",
y = "Price (USD)") +
theme_minimal()
ggplot(diamonds, aes(x = carat, y = price)) +
geom_point(alpha = 0.3, color = "steelblue") +
geom_smooth(method = "lm", color = "red", se = FALSE) +
labs(title = "Diamond Price vs Carat with Trend Line",
x = "Carat",
y = "Price (USD)") +
theme_minimal()
ggplot(diamonds, aes(x = carat, y = price)) +
geom_point(alpha = 0.3, color = "steelblue") +
labs(title = "Diamond Price vs Carat with Trend Line",
x = "Carat",
y = "Price (USD)") +
theme_minimal()
model <- lm(price ~ carat + cut + color + clarity, data = diamonds)
summary(model)
ggplot(diamonds, aes(x = carat, y = price)) +
geom_point(alpha = 0.3, color = "steelblue") +
geom_smooth(method = "lm", color = "red", se = FALSE) +
labs(title = "Diamond Price vs Carat",
x = "Carat",
y = "Price (USD)") +
theme_minimal()
View(model)
model <- lm(price ~ cut, data = diamonds)
summary(model)
diamonds$cut <- factor(diamonds$cut, ordered = FALSE)
model <- lm(price ~ cut, data = diamonds)
summary(model)
cor(diamonds)
cor(use="everything")
numeric_var <- diamonds[, sapply(diamonds, is.numeric)]
cor_matrix <- cor(numeric_var, use="everything")
View(cor_matrix)
model <- lm(price ~ carat + cut + color + clarity, data = diamonds)
summary(model)
diamonds$color <- factor(diamonds$color, ordered=FALSE)
diamonds$clarity <- factor(diamonds$clarity, ordered=FALSE)
model <- lm(price ~ carat + cut + color + clarity, data = diamonds)
summary(model)
ggplot(diamonds, aes(x = cut, y = price)) +
geom_boxplot(fill = "lightblue") +
labs(title = "Diamond Price Distribution by Cut",
x = "Cut",
y = "Price (USD)") +
theme_minimal()
View(model)
View(cor_matrix)
View(cor_matrix)
#Calculate price per carat
diamonds$price_per_carat <- diamonds$price / diamonds$carat
# Quick look
head(diamonds[, c("carat", "price", "price_per_carat")])
ggplot(diamonds, aes(x = cut, y = price_per_carat, fill = cut)) +
geom_boxplot() +
labs(title = "Price per Carat by Diamond Cut",
y = "Price per Carat",
x = "Cut")
sum(diamonds$x == 0)
sum(diamonds$y == 0)
sum(diamonds$z == 0)
?subset
diamonds_clean <- subset(diamonds, x > 0 & y > 0 & z > 0)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(caret)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(caret)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
pacman::p_load(pacman, dplyr, GGally, ggplot2, ggthemes,
ggvis, httr, lubridate, plotly, rio, rmarkdown, shiny,
stringr, tidyr)library(ggplot2)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
pacman::p_load(pacman, dplyr, GGally, ggplot2, ggthemes,
ggvis, httr, lubridate, plotly, rio, rmarkdown, shiny,
stringr, tidyr)
library(ggplot2)
library(dplyr)
library(caret)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(corrplot)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(randomForest)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
install.packages("randomForest")
install.packages("corrplot")
library(ggplot2)
library(dplyr)
library(corrplot)
library(randomForest)
library(Metrics) # for RMSE and R-squared
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
install.packages("randomForest")
install.packages("corrplot")
install.packages("Metrics")
library(ggplot2)
library(dplyr)
library(corrplot)
library(randomForest)
library(Metrics) # for RMSE and R-squared
install.packages("corrplot")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
install.packages("randomForest")
install.packages("corrplot")
install.packages("Metrics")
library(ggplot2)
library(dplyr)
library(corrplot)
library(randomForest)
library(Metrics) # for RMSE and R-squared
data(diamonds)
str(diamonds)
diamonds <- subset(diamonds, x > 0 & y > 0 & z > 0)
diamonds <- diamonds %>%
mutate(price_per_carat = price / carat,
log_price = log(price),
log_carat = log(carat))
ggplot(diamonds, aes(price)) +
geom_histogram(bins = 50, fill = "steelblue", color = "white") +
labs(title = "Distribution of Diamond Prices")
ggplot(diamonds, aes(cut, price_per_carat, fill = cut)) +
geom_boxplot() +
labs(title = "Price per Carat by Cut")
num_vars <- diamonds %>% select(price, carat, x, y, z)
corrplot(cor(num_vars), method = "number")
set.seed(123)
n <- nrow(diamonds)
train_idx <- sample(1:n, size = 0.7*n)
train <- diamonds[train_idx, ]
test  <- diamonds[-train_idx, ]
fit <- lm(log_price ~ log_carat + cut + color + clarity, data = train)
summary(fit)
set.seed(123)
rf_model <- randomForest(price ~ carat + cut + color + clarity + x + y + z,
data = train, ntree = 200, importance = TRUE)
install.packages("Metrics")
install.packages("corrplot")
install.packages("randomForest")
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(randomForest)
library(ranger)  # faster Random Forest implementation
library(ranger)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(randomForest)
library(ranger)  # faster Random Forest implementation
library(Metrics) # for RMSE and R-squared
data(diamonds)
str(diamonds)
diamonds <- subset(diamonds, x > 0 & y > 0 & z > 0)
diamonds <- diamonds %>%
mutate(price_per_carat = price / carat,
log_price = log(price),
log_carat = log(carat))
ggplot(diamonds, aes(price)) +
geom_histogram(bins = 50, fill = "steelblue", color = "white") +
labs(title = "Distribution of Diamond Prices")
ggplot(diamonds, aes(cut, price_per_carat, fill = cut)) +
geom_boxplot() +
labs(title = "Price per Carat by Cut")
num_vars <- diamonds %>% select(price, carat, x, y, z)
cor_table <- cor(num_vars)
cor_table
set.seed(123)
n <- nrow(diamonds)
train_idx <- sample(1:n, size = 0.7*n)
train <- diamonds[train_idx, ]
test  <- diamonds[-train_idx, ]
fit <- lm(log_price ~ log_carat + cut + color + clarity, data = train)
summary(fit)
set.seed(123)
train_sample <- train %>% sample_n(10000) # optional smaller subset for speed
rf_model <- ranger(price ~ carat + cut + color + clarity,
data = train_sample,
num.trees = 100,
importance = 'impurity')
rf_model
pred <- exp(predict(fit, newdata = test))
obs <- test$price
plot(obs, pred,
xlab = "Observed Price", ylab = "Predicted Price",
main = "Observed vs Predicted (Linear Regression)", pch = 19, col = rgb(0,0,1,0.4))
abline(0, 1, col = "red", lwd = 2)
residuals <- obs - pred
plot(pred, residuals,
xlab = "Predicted Price", ylab = "Residuals",
main = "Residuals vs Predicted", pch = 19, col = rgb(1,0.5,0,0.5))
abline(h = 0, col = "red", lwd = 2)
qqnorm(residuals, main = "QQ-Plot of Residuals")
qqline(residuals, col = "red", lwd = 2)
rmse_lm <- rmse(obs, pred)
r2_lm <- 1 - sum((obs - pred)^2) / sum((obs - mean(obs))^2)
rmse_lm; r2_lm
rf_pred <- predict(rf_model, data = test)$predictions
rmse_rf <- rmse(obs, rf_pred)
r2_rf <- 1 - sum((obs - rf_pred)^2) / sum((obs - mean(obs))^2)
rmse_rf; r2_rf
importance(rf_model)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(randomForest)
library(ranger)  # faster Random Forest implementation
library(Metrics) # for RMSE and R-squared
data(diamonds)
str(diamonds)
diamonds <- subset(diamonds, x > 0 & y > 0 & z > 0)
diamonds <- diamonds %>%
mutate(price_per_carat = price / carat,
log_price = log(price),
log_carat = log(carat))
ggplot(diamonds, aes(price)) +
geom_histogram(bins = 50, fill = "steelblue", color = "white") +
labs(title = "Distribution of Diamond Prices")
ggplot(diamonds, aes(cut, price_per_carat, fill = cut)) +
geom_boxplot() +
labs(title = "Price per Carat by Cut")
num_vars <- diamonds %>% select(price, carat, x, y, z)
cor_table <- cor(num_vars)
cor_table
set.seed(123)
n <- nrow(diamonds)
train_idx <- sample(1:n, size = 0.7*n)
train <- diamonds[train_idx, ]
test  <- diamonds[-train_idx, ]
fit <- lm(log_price ~ log_carat + cut + color + clarity, data = train)
summary(fit)
set.seed(123)
train_sample <- train %>% sample_n(10000) # optional smaller subset for speed
rf_model <- ranger(price ~ carat + cut + color + clarity,
data = train_sample,
num.trees = 100,
importance = 'impurity')
rf_model
pred <- exp(predict(fit, newdata = test))
obs <- test$price
plot(obs, pred,
xlab = "Observed Price", ylab = "Predicted Price",
main = "Observed vs Predicted (Linear Regression)", pch = 19, col = rgb(0,0,1,0.4))
abline(0, 1, col = "red", lwd = 2)
residuals <- obs - pred
plot(pred, residuals,
xlab = "Predicted Price", ylab = "Residuals",
main = "Residuals vs Predicted", pch = 19, col = rgb(1,0.5,0,0.5))
abline(h = 0, col = "red", lwd = 2)
qqnorm(residuals, main = "QQ-Plot of Residuals")
qqline(residuals, col = "red", lwd = 2)
rmse_lm <- rmse(obs, pred)
r2_lm <- 1 - sum((obs - pred)^2) / sum((obs - mean(obs))^2)
rmse_lm; r2_lm
rf_pred <- predict(rf_model, data = test)$predictions
rmse_rf <- rmse(obs, rf_pred)
r2_rf <- 1 - sum((obs - rf_pred)^2) / sum((obs - mean(obs))^2)
rmse_rf; r2_rf
importance(rf_model)
View(test)
data(diamonds)
head(diamonds)
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
library(ggplot2)
library(dplyr)
library(randomForest)
library(ranger)  # faster Random Forest implementation
library(Metrics) # for RMSE and R-squared
library(corrplot)
sum(is.na(diamonds))
any(diamonds == "")
diamonds$cut <- factor(diamonds$cut, ordered = FALSE)
diamonds$color <- factor(diamonds$color, ordered=FALSE)
diamonds$clarity <- factor(diamonds$clarity, ordered=FALSE)
fit <- lm(log_price ~ log_carat + cut + color + clarity, data = train)
summary(fit)
options(contrasts = c("contr.treatment", "contr.poly"))
fit <- lm(log_price ~ log_carat + cut + color + clarity, data = train)
summary(fit)
options(contrasts = c("contr.treatment", "contr.poly"))
fit <- lm(log_price ~ log_carat + cut + color + clarity, data = train)
summary(fit)
train$cut    <- factor(train$cut, ordered = FALSE)
train$color  <- factor(train$color, ordered = FALSE)
train$clarity <- factor(train$clarity, ordered = FALSE)
fit <- lm(log_price ~ log_carat + cut + color + clarity, data = train)
summary(fit)
#R Shiny tutorial
install.packages("shiny")
library(shiny)
runExample("01_hello")
library(bslib)
# Define UI for app that draws a histogram ----
ui <- page_sidebar(
# App title ----
title = "Hello Shiny!",
# Sidebar panel for inputs ----
sidebar = sidebar(
# Input: Slider for the number of bins ----
sliderInput(
inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30
)
),
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
View(ui)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
# Define UI for app that draws a histogram ----
ui <- page_sidebar(
# App title ----
title = "Hello Shiny!",
# Sidebar panel for inputs ----
sidebar = sidebar(
# Input: Slider for the number of bins ----
sliderInput(
inputId = "bins",
label = "Number of bins:",
min = 1,
max = 50,
value = 30
)
),
# Output: Histogram ----
plotOutput(outputId = "distPlot")
)
# Define server logic required to draw a histogram ----
server <- function(input, output) {
# Histogram of the Old Faithful Geyser Data ----
# with requested number of bins
# This expression that generates a histogram is wrapped in a call
# to renderPlot to indicate that:
#
# 1. It is "reactive" and therefore should be automatically
#    re-executed when inputs (input$bins) change
# 2. Its output type is a plot
output$distPlot <- renderPlot({
x    <- faithful$waiting
bins <- seq(min(x), max(x), length.out = input$bins + 1)
hist(x, breaks = bins, col = "#007bc2", border = "white",
xlab = "Waiting time to next eruption (in mins)",
main = "Histogram of waiting times")
})
}
shinyApp(ui = ui, server = server)
runApp("App-1")
runApp("App-1")
runApp("App-1")
rlang::last_trace()
runApp("App-1")
runApp("App-1")
shiny::runApp('R/App-1')
source('R/App-1/R Shiny tutorial.R')
runApp("App-1")
runApp("R/App-1")
runApp("R/App-1")
runApp("R/App-1")
runApp("R/App-1")
runApp("R/App-1")
runApp("R/App-1")
runApp('R/App-1')
runApp("App-1")
runApp('R/App-1')
runApp("R/App-1")
runApp('R/App-1')
runApp('R/App-1')
runApp("R/App-1")
runApp('R/App-1')
runApp('R/App-1')
runApp("R/App-1")
runApp("~/R/App-1")
runApp("R/App-1")
rlang::last_trace()
runApp("R\App-1")
runApp("App-1")
runApp("~/App-1")
getwd()
runApp("/R/App-1")
runApp("C:\Users\MiGoreng\OneDrive\Documents\R\App-1")
runApp("C:/Users/MiGoreng/OneDrive/Documents/R/App-1")
runApp("C:/Users/MiGoreng/OneDrive/Documents/R/App-1")
runApp("~/R/App-1")
runApp('R/App-1')
runApp('R/App-1')
1+2
4*5
30/4
x <- 3+5
x
8^3
x^3
sqrt(16)
height <- c(145, 150, 111, 172, 162)
class(height)
mean(height)
factor(height)
gender <- c("f", "m", "f", "f", "m")
class(gender)
factor(gender)
?factor
?mean
install.packages("fable")
library(fable)
library(fontawesome)
setwd("~/GitHub/DataStudio-Webpage")
